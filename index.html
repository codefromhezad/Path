<html>
	<head>
		<meta charset="utf-8">
		<title>Javascript Path Tracing</title>

		<script src="vendor/sylvester.js"></script>
		<script src="constants.js"></script>
		<script src="renderers.js"></script>
		<script src="cameras.js"></script>
		<script src="entities.js"></script>
	</head>
	<body>
		<canvas id="preview-canvas" width="200" height="200"></canvas>

		<script>

			var globals = {
				currentScreenX: 0,
				currentScreenY: 0
			}

			function vecOrtho(v) {
			    if( Math.abs(v.elements[0]) > Math.abs(v.elements[2]) ) {
			    	return $V([-v.elements[1], v.elements[0], 0.0]);
			    } else {
			    	return $V([0.0, -v.elements[2], v.elements[1]]);
			    }
			}

			function rand2n() {
			    return $V([ (globals.currentScreenX + Math.random()) % 1, (globals.currentScreenY + Math.random()) % 1])
			}

			function getRandomVectorInHemisphere(normal) {
				var o1 = vecOrtho(normal).toUnitVector();
				var o2 = normal.cross(o1).toUnitVector();
				var r = rand2n();
				r.elements[0] = r.elements[0] * 2.0 * Math.PI;
				var oneminus = Math.sqrt(1.0 - r.elements[1] * r.elements[1]);

				var v1 = o1.multiply(Math.cos(r.elements[0]) * oneminus);
				var v2 = o2.multiply(Math.sin(r.elements[0]) * oneminus)
				var v3 = normal.multiply(r.elements[1]);
				return v1.add(v2.add(v3));
			}

			var Ray = function(origin, direction) {
				this.origin = origin;
				this.direction = direction;
			}

			var Pathtracer = new (function() {

				this.camera;
				this.renderer;
				this.objects = [];

				this.boot = function(canvasId) {
					this.canvas = document.getElementById(canvasId);
					this.ctx    = this.canvas.getContext('2d');
					this.width  = this.canvas.width;
					this.height = this.canvas.height;
					this.demiWidth = this.width * 0.5;
					this.demiHeight = this.height * 0.5;
					this.imageData = this.ctx.createImageData(this.width, this.height);
					this.imageBuffer = this.imageData.data;

					this.aspectRatio = this.height / this.width;
				}

				this.traceRay = function(ray) {
					var nearestIntersection = null;

					for(var n in this.objects) {
						var o = this.objects[n];
						var intersection = o.intersect(ray);

						if( intersection && intersection.status == INTERSECT_OK ) {
							if( (! nearestIntersection) || nearestIntersection.distance > intersection.distance ) {
								nearestIntersection = intersection;
							}
						}
					}

					return nearestIntersection;
				}

				this.render = function() {
					if( ! this.camera ) {
						console.error('A camera must be defined.');
						return;
					}

					for(var y = 0; y < this.height; y++) {
						globals.currentScreenY = y;
						for(var x = 0; x < this.width; x++) {
							globals.currentScreenX = x;

							var ray = this.camera.getRay(x, y);
							var intersect = this.traceRay(ray);
							var c = this.renderer.getColor(intersect);

							this.setPixel(x, y, c[0] * 255, c[1] * 255, c[2] * 255);
						}
					}

					this.flush();
				}

				this.setPixel = function(x, y, r, g, b, a) {
					if( a === undefined ) { 
						a = 255;
					}
					var index = ( (x|0) + (y|0) * this.width) * 4;
				    this.imageBuffer[index+0] = r | 0;
				    this.imageBuffer[index+1] = g | 0;
				    this.imageBuffer[index+2] = b | 0;
				    this.imageBuffer[index+3] = a | 0;
				}

				this.flush = function() {
					this.ctx.putImageData(this.imageData, 0, 0);
				}
			})();

			/* Start */
			Pathtracer.boot('preview-canvas');

			Pathtracer.renderer = new Renderer.zBuffer({depthScale: 10, depthOffset: 0});
			Pathtracer.camera = new Camera.orthographic( $V([0, 1, -20]), 20, 10);

			Pathtracer.objects.push(new Entity.sphere( $V([-3, 1, 10]), 4));
			Pathtracer.objects.push(new Entity.sphere( $V([3, 1, 10]), 4));
			Pathtracer.objects.push(new Entity.sphere( $V([0, -47, 50]), 50));

			Pathtracer.render();
		</script>
	</body>
</html>
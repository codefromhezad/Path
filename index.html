<html>
	<head>
		<meta charset="utf-8">
		<title>Javascript Path Tracing</title>

		<script src="vendor/sylvester.js"></script>
		<script src="constants.js"></script>
		<script src="utils.js"></script>
		<script src="color.js"></script>
		<script src="renderers.js"></script>
		<script src="cameras.js"></script>
		<script src="entities.js"></script>
	</head>
	<body>
		<canvas id="preview-canvas" width="200" height="200"></canvas>

		<script>

			var Ray = function(origin, direction) {
				this.origin = origin;
				this.direction = direction;

				this.lastHitPosition = null;
				this.lastHitNormal = null;

				this.cast = function(sceneObjects) {
					var nearestIntersection = null;

					for(var n in sceneObjects) {
						var o = sceneObjects[n];
						var intersection = o.intersect(this);

						if( intersection && intersection.status == INTERSECT_OK ) {
							if( (! nearestIntersection) || nearestIntersection.distance > intersection.distance ) {
								nearestIntersection = intersection;
							}
						}
					}

					if( nearestIntersection ) {
						this.lastHitPosition = nearestIntersection.ray.origin.add(nearestIntersection.ray.direction.multiply(nearestIntersection.distance));
						this.lastHitNormal = nearestIntersection.object.getNormal(this.lastHitPosition);
					}

					return nearestIntersection;
				}
			}

			var Engine = new (function() {

				this.screenBuffer = [];

				this.camera;
				this.renderer;
				this.objects = [];

				this.seed2d = $V([0.0, 0.0]);

				this.boot = function(canvasId) {
					this.canvas = document.getElementById(canvasId);
					this.ctx    = this.canvas.getContext('2d');
					this.width  = this.canvas.width;
					this.height = this.canvas.height;
					this.demiWidth = this.width * 0.5;
					this.demiHeight = this.height * 0.5;
					this.imageData = this.ctx.createImageData(this.width, this.height);
					this.imageBuffer = this.imageData.data;

					this.aspectRatio = this.height / this.width;

					if( DEBUG ) {
						console.log('[Engine] Booting. Resolution: ('+this.width+','+this.height+'), Aspect Ratio (h/w): '+this.aspectRatio);
					}

					for(var i = 0; i < this.width; i++) {
						this.screenBuffer[i] = [];
					}
				}

				this.setRenderer = function(rendererName, opts) {
					var rendererComponent = Renderer[rendererName];

					if( rendererComponent ) {
						this.renderer = new rendererComponent(opts);

						if( DEBUG && this.renderer.defaults ) {
							console.log('[Renderer|'+rendererName+'] + Settings: ', this.renderer.options);
						}

						return true;
					} else {
						console.error('Can\'t find any renderer called "'+rendererName+'"');
						return false;
					}
				}

				this.setCamera = function(cameraName, opts) {
					var cameraComponent = Camera[cameraName];

					if( cameraComponent ) {

						this.camera = new cameraComponent(opts);

						if( DEBUG ) {
							console.log('[Camera|'+cameraName+'] + Settings: ', opts);
						}

						return true;
					} else {
						console.error('Can\'t find any camera called "'+cameraName+'"');
						return false;
					}
				}

				this.render = function() {
					if( ! this.camera ) {
						console.error('A camera must be defined.');
						return;
					}
					if( ! this.renderer ) {
						console.error('A renderer must be defined.');
						return;
					}

					if( DEBUG ) {
						console.log('[Engine] Rendering ...');
						var startTime = Math.floor(Date.now() / 1000);
					}

					var y = 0;
					var that = this;

					var renderProcess = function() {
						for(var x = 0; x < that.width; x++) {
							var ray = that.camera.getRay(x, y);

							that.seed2d = $V([x, y]);
							
							var finalColor = that.renderer.getColorForRay(ray);
							that.setPixel(x, y, finalColor.to255());
						}

						if( DEBUG ) {
							var perTen = (100 * (y + 1) / that.height);
							if( perTen % 10 == 0 ) {
								console.log(' > ' + perTen + "%");
							}
						}

						y += 1;

						if (y < that.height) {
						    setTimeout(renderProcess, 1);
						} else {
							if( DEBUG ) {
								var finishTime = Math.floor(Date.now() / 1000);
								console.log('[Engine] Rendering done in '+(finishTime - startTime)+' seconds.');
							}

							that.flush();
						}
					}

					renderProcess();
				}

				this.setPixel = function(x, y, color) {
					var index = ( (x|0) + (y|0) * this.width) * 4;
				    this.imageBuffer[index+0] = color.r | 0;
				    this.imageBuffer[index+1] = color.g | 0;
				    this.imageBuffer[index+2] = color.b | 0;
				    this.imageBuffer[index+3] = color.a | 0;
				}

				this.flush = function() {
					this.ctx.putImageData(this.imageData, 0, 0);
				}
			})();

			/* Start */
			Engine.boot('preview-canvas');

			Engine.setRenderer('zBuffer', {traceDepth: 4});
			Engine.setCamera('orthographic', {
				position: $V([0, 1, -20]),
				viewportWidth: 20,
				viewportDistance: 10
			});

			Engine.objects.push(new Entity.sphere( $V([-5, 1, 10]), 4));
			Engine.objects.push(new Entity.sphere( $V([4, 1, 10]), 4));
			Engine.objects.push(new Entity.plane( $V([0, -3, 11]), $V([0, 0.8, -0.2])));

			Engine.render();
		</script>
	</body>
</html>
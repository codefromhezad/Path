<html>
	<head>
		<meta charset="utf-8">
		<title>Javascript Path Tracing</title>

		<script src="vendor/sylvester.js"></script>
		<script src="constants.js"></script>
		<script src="utils.js"></script>
		<script src="color.js"></script>
		<script src="renderers.js"></script>
		<script src="cameras.js"></script>
		<script src="entities.js"></script>
	</head>
	<body>
		<canvas id="preview-canvas" width="200" height="200"></canvas>

		<script>

			var globals = {
				currentScreenX: 0,
				currentScreenY: 0,
			}

			var Ray = function(origin, direction) {
				this.origin = origin;
				this.direction = direction;

				this.cast = function(sceneObjects) {
					var nearestIntersection = null;

					for(var n in sceneObjects) {
						var o = sceneObjects[n];
						var intersection = o.intersect(this);

						if( intersection && intersection.status == INTERSECT_OK ) {
							if( (! nearestIntersection) || nearestIntersection.distance > intersection.distance ) {
								nearestIntersection = intersection;
							}
						}
					}

					return nearestIntersection;
				}
			}

			var Engine = new (function() {

				this.screenBuffer = [];

				this.camera;
				this.renderer;
				this.objects = [];

				this.boot = function(canvasId) {
					if( DEBUG ) {
						console.log('Booting engine.');
					}

					this.canvas = document.getElementById(canvasId);
					this.ctx    = this.canvas.getContext('2d');
					this.width  = this.canvas.width;
					this.height = this.canvas.height;
					this.demiWidth = this.width * 0.5;
					this.demiHeight = this.height * 0.5;
					this.imageData = this.ctx.createImageData(this.width, this.height);
					this.imageBuffer = this.imageData.data;

					this.aspectRatio = this.height / this.width;

					for(var i = 0; i < this.width; i++) {
						this.screenBuffer[i] = [];
					}
				}

				this.setRenderer = function(rendererName, opts) {
					var rendererComponent = Renderer[rendererName];

					if( rendererComponent ) {
						if( DEBUG ) {
							console.log('Using "'+rendererName+'" renderer.');
						}

						this.renderer = new rendererComponent(opts);

						if( DEBUG && this.renderer.defaults ) {
							console.log(' + Renderer settings: ');
							console.log('   > ', this.renderer.options);
						}

						return true;
					} else {
						console.error('Can\'t find any renderer called "'+rendererName+'"');
						return false;
					}
				}

				this.render = function() {
					if( ! this.camera ) {
						console.error('A camera must be defined.');
						return;
					}
					if( ! this.renderer ) {
						console.error('A renderer must be defined.');
						return;
					}

					if( DEBUG ) {
						console.log('Starting render ...');
						var startTime = Math.floor(Date.now() / 1000);
					}

					for(var y = 0; y < this.height; y++) {
						globals.currentScreenY = y;
						for(var x = 0; x < this.width; x++) {
							globals.currentScreenX = x;

							var ray = this.camera.getRay(x, y);
							var intersect = ray.cast(this.objects);
							
							var finalColor = this.renderer.getColor(intersect);
							this.setPixel(x, y, finalColor.to255());
						}

						if( DEBUG ) {
							var perTen = (100 * (y + 1) / this.height);
							if( perTen % 10 == 0 ) {
								console.log(perTen + "%");
							}
						}
					}

					if( DEBUG ) {
						var finishTime = Math.floor(Date.now() / 1000);
						console.log('Done. Image rendered in '+(finishTime - startTime)+' seconds.');
					}

					this.flush();
				}

				this.setPixel = function(x, y, color) {
					var index = ( (x|0) + (y|0) * this.width) * 4;
				    this.imageBuffer[index+0] = color.r | 0;
				    this.imageBuffer[index+1] = color.g | 0;
				    this.imageBuffer[index+2] = color.b | 0;
				    this.imageBuffer[index+3] = color.a | 0;
				}

				this.flush = function() {
					this.ctx.putImageData(this.imageData, 0, 0);
				}
			})();

			/* Start */
			Engine.boot('preview-canvas');

			Engine.setRenderer('pathtracer', {traceDepth: 20});
			Engine.camera = new Camera.orthographic( $V([0, 1, -20]), 20, 10);

			Engine.objects.push(new Entity.sphere( $V([-5, 1, 10]), 4));
			Engine.objects.push(new Entity.sphere( $V([4, 1, 10]), 4));
			Engine.objects.push(new Entity.plane( $V([0, -3, 11]), $V([0, 0.8, -0.2])));

			Engine.render();
		</script>
	</body>
</html>
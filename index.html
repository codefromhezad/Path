<html>
	<head>
		<meta charset="utf-8">
		<title>Path | A modular raytracer</title>

		<style>
			html, body {
				margin: 0;
				padding: 0;
			}
		</style>

		<link type="text/css" rel="stylesheet" href="css/path_debug.css">

		<script src="vendor/jquery-2.1.3.min.js"></script>
		<script src="vendor/sylvester.js"></script>

		<script src="constants.js"></script>
		<script src="utils.js"></script>
		<script src="debug.js"></script>
		<script src="color.js"></script>
		<script src="renderers.js"></script>
		<script src="cameras.js"></script>
		<script src="entities.js"></script>
	</head>
	<body>
		<canvas id="preview-canvas" width="200" height="200"></canvas>

		<script>

			var Ray = function(origin, direction) {
				this.origin = origin;
				this.direction = direction;

				this.lastHitPosition = null;
				this.lastHitNormal = null;

				this.cast = function(sceneObjects) {
					var nearestIntersection = null;

					for(var n in sceneObjects) {
						var o = sceneObjects[n];
						var intersection = o.intersect(this);

						if( intersection && intersection.status == INTERSECT_OK ) {
							if( (! nearestIntersection) || nearestIntersection.distance > intersection.distance ) {
								nearestIntersection = intersection;
							}
						}
					}

					if( nearestIntersection ) {
						this.lastHitPosition = nearestIntersection.ray.origin.add(nearestIntersection.ray.direction.multiply(nearestIntersection.distance));
						this.lastHitNormal = nearestIntersection.object.getNormal(this.lastHitPosition);
					}

					return nearestIntersection;
				}
			}

			var Engine = new (function() {

				this.screenBuffer = [];

				this.camera;
				this.renderer;
				this.objects = [];

				this.seed2d = $V([0.0, 0.0]);

				this.boot = function(canvasId) {
					this.canvas = document.getElementById(canvasId);
					this.ctx    = this.canvas.getContext('2d');
					this.width  = this.canvas.width;
					this.height = this.canvas.height;
					this.demiWidth = this.width * 0.5;
					this.demiHeight = this.height * 0.5;
					this.imageData = this.ctx.createImageData(this.width, this.height);
					this.imageBuffer = this.imageData.data;

					this.aspectRatio = this.height / this.width;

					Debug.as('engine').show('Booting with settings: ', {width: this.width, height: this.height, aspectRatio: this.aspectRatio});
					
					for(var i = 0; i < this.width; i++) {
						this.screenBuffer[i] = [];
					}
				}

				this.setRenderer = function(rendererName, opts) {
					var rendererComponent = Renderer[rendererName];

					if( rendererComponent ) {
						this.renderer = new rendererComponent(opts);

						if( this.renderer.options ) {
							Debug.as('renderer').show('Using <em>'+rendererName+'</em> renderer with settings: ', this.renderer.options);
						} else {
							Debug.as('renderer').show('Using <em>'+rendererName+'</em> renderer.');
						}

						return true;
					} else {
						console.error('Can\'t find any renderer called "'+rendererName+'"');
						return false;
					}
				}

				this.setCamera = function(cameraName, opts) {
					var cameraComponent = Camera[cameraName];

					if( cameraComponent ) {

						this.camera = new cameraComponent(opts);

						Debug.as('camera').show('Using <em>'+cameraName+'</em> camera with settings: ', this.camera.options);

						return true;
					} else {
						console.error('Can\'t find any camera called "'+cameraName+'"');
						return false;
					}
				}

				this.render = function() {
					if( ! this.camera ) {
						console.error('A camera must be defined.');
						return;
					}
					if( ! this.renderer ) {
						console.error('A renderer must be defined.');
						return;
					}

					Debug.as('engine').startProcess('Rendering');

					var y = 0;
					var that = this;

					var renderProcess = function() {
						for(var x = 0; x < that.width; x++) {
							var ray = that.camera.getRay(x, y);

							that.seed2d = $V([x, y]);
							
							var finalColor = that.renderer.getColorForRay(ray);
							that.setPixel(x, y, finalColor.to255());
						}

						Debug.updateProgress(y, that.height);

						y += 1;

						if (y < that.height) {
						    setTimeout(renderProcess, 1);
						} else {
							Debug.stopProcess();
							that.flush();
						}
					}

					renderProcess();
				}

				this.setPixel = function(x, y, color) {
					var index = ( (x|0) + (y|0) * this.width) * 4;
				    this.imageBuffer[index+0] = color.r | 0;
				    this.imageBuffer[index+1] = color.g | 0;
				    this.imageBuffer[index+2] = color.b | 0;
				    this.imageBuffer[index+3] = color.a | 0;
				}

				this.flush = function() {
					this.ctx.putImageData(this.imageData, 0, 0);
				}
			})();

			/* Start */
			$( function() {
				Engine.boot('preview-canvas');

				Engine.setRenderer('pathtracer', {traceDepth: 4});
				Engine.setCamera('orthographic', {
					position: $V([0, 1, -20]),
					viewportWidth: 20,
					viewportDistance: 10
				});

				Engine.objects.push(new Entity.sphere( $V([-5, 1, 10]), 4));
				Engine.objects.push(new Entity.sphere( $V([4, 1, 10]), 4));
				Engine.objects.push(new Entity.plane( $V([0, -3, 11]), $V([0, 0.8, -0.2])));

				Engine.render();
			});

		</script>
	</body>
</html>